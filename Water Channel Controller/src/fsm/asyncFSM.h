#ifndef __ASYNC_FSM__
#define __ASYNC_FSM__

#define MAX_EVQUEUE_SIZE 20 
#define NUM_PINS 14

/*
* Gestione della logica della FSM. Realizzata da prof. Alessandro Ricci. Adattata al progetto in questione.
* Permalink: https://github.com/pslab-unibo/esiot-2023-2024/tree/4ed681b4eed6ae8f0fc0d01e3f95fd1ca97741c6/Arduino/module-lab-2.4/button-led-async-fsm 
* Gestisce tutte le creazioni degli eventi, tranne quelli della seriale che fanno affidamento all UART per l'interrupt (Serial.available()) e generano 
* l'evento direttamente nel main.
*/

//Event class: constructor, getType
class Event {
    public:
        Event(int type);
        int getType();
    private:
        int type;
};

//Observer class
class Observer {
    public:
        virtual void notifyEvent(Event* ev);
};

//Event source class, generated Event and Observer
class EventSource {
    public:
        void registerObserver(Observer* observer);

        virtual void notifyInterrupt(int pin) = 0;

    protected:
        void bindInterrupt(int pin);
        void generateEvent(Event* ev);
        Observer* observer;
};

//Class to bind interrupt to event sources
class InterruptDispatcher {
    public:
        InterruptDispatcher();
        void bind(int pin, EventSource* src);
        void notifyInterrupt(int pin);
    private:
        EventSource* sourceRegisteredOnPin[NUM_PINS];
        void(*notifyFunctions[NUM_PINS])() = {};
        static void notifyInterrupt_0();
        static void notifyInterrupt_1();
        static void notifyInterrupt_2();
        static void notifyInterrupt_3();
        static void notifyInterrupt_4();
        static void notifyInterrupt_5();
        static void notifyInterrupt_6();
        static void notifyInterrupt_7();
        static void notifyInterrupt_8();
        static void notifyInterrupt_9();
        static void notifyInterrupt_10();
        static void notifyInterrupt_11();
        static void notifyInterrupt_12();
        static void notifyInterrupt_13();
        static void notifyInterrupt_A0();
};


//Class for events queue
class EventQueue {      
    public:
        EventQueue();
        bool isEmpty();
        void enqueue(Event* ev);
        Event* dequeue();  
    private:
        Event* queue[MAX_EVQUEUE_SIZE];
        int head, tail; 
};

/**
 * Base abstract class for implementing asynchronous
 * Finite State Machines.
 * 
 * NOTES:
 * - it is an Observer of events generated by event source
 * - the state is meant to be modelled by derived classes
 */
class AsyncFSM : public Observer {
    public:
        enum Mode {AUTOMATIC, MANUAL, ADMIN};

        virtual void handleEvent(Event* ev) = 0;
        virtual void setCurrentMode(char str[]) = 0;
        virtual void setAngle(int angle) = 0;
        virtual bool isManual();
        void notifyEvent(Event* ev);  
        void checkEvents();  
        
    protected:
        AsyncFSM();    
        EventQueue eventQueue;
};

#endif